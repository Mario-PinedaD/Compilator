options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(linkers)

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter; 
import java.util.*;
import java.io.*;

class linkers {
    private static CodigoCPP generador;
    // Tabla de errores
    static ArrayList<String> tabla = linkersTokenManager.tablaErrores;
    static Map<String, String> declaredVariables = new HashMap<String, String>();
    static String acumulador_cpp = "";

    static ArrayList<String> casos = new ArrayList<>();

    public static void main(String[] args) throws FileNotFoundException {
        String archivo = "codigo_objeto";
        generador = new CodigoCPP("./", archivo);

        try {
            linkers link = new linkers(System.in);
            link.Programalink();

            if (!link.tabla.isEmpty()) {
                System.out.println("\u001B[31m\nErrores encontrados:\n\u001B[0m");
                for (String error : link.tabla) {
                    System.out.println(error);
                }
            } else {
                System.out.println("\u001B[32mAnálisis exitoso\u001B[0m");
                // System.out.print(acumulador_cpp);
                compilarEjecutable("./" + archivo + ".cpp");
            }

        } catch (ParseException e) {
            System.out.println("Error de Análisis -> " + e.getMessage());
        }
    }

    static void checkAndAddVariable(Token id, String type, int line, int column) {
        if (declaredVariables.containsKey(id.image)) {
            tabla.add("Error Semántico -> Variable repetida: " + id.image + " en línea " + line + ", columna " + column);
        } else {
            declaredVariables.put(id.image, type);
        }
    }
    
    static String obtenerNombreArchivo(File archivo) {
        String nombre = archivo.getName();
        int pos = nombre.lastIndexOf(".");
        return pos > 0 ? nombre.substring(0, pos) : nombre;
    }

    static void compilarEjecutable(String sourcePath) {
        String output = sourcePath.replace(".cpp", " ");
        ProcessBuilder pb = new ProcessBuilder("g++", sourcePath, "-o", output);
        try {
            Process proceso = pb.start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(proceso.getInputStream()));
            BufferedReader errorReader = new BufferedReader(new InputStreamReader(proceso.getErrorStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            while ((line = errorReader.readLine()) !=  null) {
                System.err.println(line);
            }
            int exitCode = proceso.waitFor();
            System.out.println("GCC terminó con el código de salida: " + exitCode);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // static void ejecutarCompilado(String file) {
    //     ProcessBuilder pb = new ProcessBuilder(file);
    //     try {
    //         Process proceso = pb.start();
    //         BufferedReader reader = new BufferedReader(new InputStreamReader(proceso.getInputStream()));
    //         BufferedReader errorReader = new BufferedReader(new InputStreamReader(proceso.getErrorStream()));
    //         String line;
    //         while ((line = reader.readLine()) != null) {
    //             System.out.println(line);
    //         }
    //         while ((line = errorReader.readLine()) !=  null) {
    //             System.err.println(line);
    //         }
    //         int exitCode = proceso.waitFor();
    //     } catch (IOException e) {
    //         e.printStackTrace();
    //     } catch (InterruptedException e) {
    //         e.printStackTrace();
    //     }
    // }

    static class CodigoCPP {
        private File file;
        public CodigoCPP(String path, String nombreFuente) {
            String fullPath = path.replaceFirst("^~", System.getProperty("user.home"));
            file = new File(fullPath + nombreFuente + ".cpp");
            limpiarBuffer();
            escribirCPP(
                "#include <iostream>\n" +
                // "#include <Windows.h>\n" +
                "using namespace std;\n" +
                "int main() {\n" 
                // "\tSetConsoleOutputCP(CP_UTF8);\n"
            );
        }

        public void escribirCPP(String linea) {
            try {
                FileWriter writer = new FileWriter(file, true);
                BufferedWriter BufWriter = new BufferedWriter(writer);
                PrintWriter PrintW = new PrintWriter(BufWriter);
                PrintW.write(linea);
                PrintW.close();
                BufWriter.close();
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println("Error al tratar de escribir en el archivo CPP");
            }
        }

        public void limpiarBuffer() {
            try {
                FileWriter writer = new FileWriter(file, false);
                BufferedWriter BufWriter = new BufferedWriter(writer);
                PrintWriter PrintW = new PrintWriter(BufWriter);
                PrintW.write("");
                PrintW.close();
                BufWriter.close();
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println("Error al tratar de limpiar el buffer");
            }
        }
    }

    static class Parameter {
        String type;
        String name;
    
        public Parameter(String type, String name) {
            this.type = type;
            this.name = name;
        }

        public Parameter() {

        }
    }

}

PARSER_END(linkers)

TOKEN_MGR_DECLS : {
    static ArrayList<String> tablaErrores = new ArrayList<String>();

    public void LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
        String errorMessage = "Error Léxico -> Línea: " + errorLine + ", Columna: " + errorColumn + ", Descripción: ";
        if (EOFSeen) {
            errorMessage += "<EOF> encontrado, pero esperaba más caracteres.";
        } else {
            errorMessage += "\"" + curChar + "\" encontrado, pero esperaba más caracteres.";
        }
        linkers.tabla.add(errorMessage); // Corregido para apuntar a 'tabla'
    }
}

TOKEN: {//PALABRAS RESERVADAS
    <ReservadaInicio: "INICIAR">
    | <Lectura: "Leer">
    | <Escritura: "Escribir">
    | <CondicionalIf: "if">
    | <CondicionalElse: "else"> 
    | <CondicionalSwitch: "Switch">
    | <CicloWhile: "While">
    | <CicloFor: "For">
    | <Default: "Default">
    | <Caso: "Caso">
    | <Break: "Break">
    | <VERDADERO: "Verdadero">
    | <FALSO: "Falso">
    | <PUBLICO: "Publico">
    | <PRIVADO: "Privado">
    | <NoRetorno: "NoRetorno">
    | <Start: "Start">
    | <End: "End">
    | <Funcion: "Funcion">
    | <Retorno: "Retorno">
    | <LlamarFuncion: "call">
}

TOKEN: {// TIPOS DE DATO
    <TipoDatoEntero: "Entero">
    | <TipoDatoDecimal: "Decimal">
    | <TipoDatoBooleano: "boolean">
    | <TipoDatoCadena: "Cadena">
    | <TIpoDatoCaracter: "Caracter">
}

TOKEN: { //CARACTERES
    <LlaveAbre: "{">
    | <LlaveCierra: "}">
    | <ParentesisAbre: "(">
    | <ParentesisCierra: ")">
    | <DelimitadorLineaDeCodigo: ";">
    | <DelimitadorCasoSwitch: ":">
    | <CorcheteAbre: "[">
    | <CorcheteCierra: "]">
    | <Coma: ",">
}

TOKEN: {// OPERADORES ARITMETICOS
     <OperacionSuma: "+">
    | <OperacionResta: "-">
    | <OperacionMultiplicacion: "*">
    | <OperacionDivision: "/">
    | <OperacionResiduo: "%">
    | <OperacionIncremento: "+=">
    | <OperacionDecremento: "-=">
    | <OperadorIncremento: "++">
    | <OperadorDecremento: "--">
}

TOKEN: {// OPERADORES RELACIONALES
    <Asignacion: "=">
    | <OperacionMayorQue: ">">
    | <OperacionMenorQue: "<">
    | <OperacionMenorOIgualQue: "<=">
    | <OperacionMayorOIgualQue: ">=">
    | <OperacionIgualdad: "==">
    | <OperacionDesigualdad: "!=">
}

TOKEN: {// OPERADORES LOGICOS
    <OperacionAnd: "&">
    | <OperacionOr: "|">
    | <OperacionNot: "!">
}

TOKEN: {
    <CADENA: "\""(~["\""])*"\"">
    | <IDENTIFICADOR: (<LETRA>)+ (<LETRA>|<NUMERO>)* >
    | <NUMERO_FLOTANTE: (["0"-"9"])+"."(["0"-"9"])+>
    | <NUMERO: (["0"-"9"])+>
    | <LETRA: (["A"-"Z","a"-"z","á","é","í","ó","ú"])+>
}

SKIP: {
    " " | "\t" | "\r" | "\n"
    |
    <"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")>
    |
    <"/*" (~["*"])* ("*" ~["/"] (~["*"])* )* "*/">
}

SPECIAL_TOKEN: {
    < ANYTHING : ~[] > // Esto capturará cualquier token no definido
    {
        linkers.tabla.add("Error Léxico -> Línea: " + input_stream.getEndLine() + ", Columna: " + input_stream.getEndColumn() + ", Token no reconocido.");
    }
}

void Programalink() : {}{
    try {
        (
            try{<ReservadaInicio> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());}
            try{<LlaveAbre> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());}

            (sentencias())*

            try{<LlaveCierra> }catch(ParseException e){tabla.add("Error de Sintaxis -> " + e.getMessage());} )

            // (procedimiento())*
            // (funcion())*

            {
                generador.escribirCPP(acumulador_cpp);
                generador.escribirCPP("\tcout << \"\\nPresiona Enter para salir...\";\n");
                generador.escribirCPP("\tcin.ignore();\n");
                generador.escribirCPP("\tcin.get();\n");
                generador.escribirCPP("\treturn 0;\n}");
            }
            
            <EOF>
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != EOF);

        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void sentencias() : {} {
    declararVariables()
    | asignacion()
    | entrada()
    | salida()
    | condicionalIf()
    | cicloFor()
    | cicloWhile()
    | condicionalSwitch()
    // | llamadaFuncion()
} 


void verificarExistenciaVariable(Token token) : {} {
    {
        if (!linkers.declaredVariables.containsKey(token.image)) {
            linkers.tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        }
    }
}

/**
 * Verifica la existencia de un token y obtiene su tipo.
 *
 * @param token El token que se va a verificar.
 * @return El tipo del token si existe, de lo contrario, un valor que indique que no existe.
 * @throws SomeException Si ocurre un error durante la verificación.
 */
String verificarExistenciaYObtenerTipo(Token token) : {
    String tipo;
} {
    {
        if (token.kind == linkersConstants.IDENTIFICADOR) {
            if (linkers.declaredVariables.containsKey(token.image)) {
                tipo = linkers.declaredVariables.get(token.image);
            } else {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                tipo = "error";
            }
        } else if (token.kind == linkersConstants.NUMERO) {
            tipo = "int";
        } else if (token.kind == linkersConstants.NUMERO_FLOTANTE) {
            tipo = "float";
        } else if (token.kind == linkersConstants.VERDADERO || token.kind == linkersConstants.FALSO) {
            tipo = "boolean";
        } else if (token.kind == linkersConstants.CADENA) {
            tipo = "string";
        } else if (token.kind == linkersConstants.LETRA) {
            tipo = "char";
        }
        else {
            tipo = "error";
        }
    }
    { return tipo; }
}

void declararVariables() : {} {
    VariableINT() 
    | VariableFLOAT() 
    | VariableBOOLEAN() 
    | VariableCADENA() 
    | VariableCARACTER()
}

/**
 * Este método `VariableINT` se utiliza para definir una variable de tipo entero (INT).
 * 
 * Variables locales:
 * - `Token id`: Representa el identificador del token.
 * - `int line`: Almacena el número de línea donde se encuentra la variable.
 * - `int column`: Almacena el número de columna donde se encuentra la variable.
 * - `boolean control`: Bandera de control que inicialmente está establecida en falso.
 * 
 * Este método no tiene parámetros de entrada ni valores de retorno.
 */
void VariableINT() : {
    Token id, num;
    int line, column;
    String codigo_temporal = "";
    boolean control = false;
} {
    try {
        <TipoDatoEntero>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO || linkers.declaredVariables.containsKey(token.image)) {
                        control = true;
                        linkers.checkAndAddVariable(id, "int[]", line, column);
                        codigo_temporal = "\t int " + id.image + "[" + token.image + "]";
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "int", line, column);
                codigo_temporal = "\tint " + id.image;
            }
        }
        [ <Asignacion> 
            try {
                num = <NUMERO>
                { codigo_temporal += " = " + num.image; }
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        ]
        <DelimitadorLineaDeCodigo>
        { 
            codigo_temporal += "; \n";
            acumulador_cpp += codigo_temporal;
         }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * * Inicializa un token para contener el identificador de la variable, y variables para almacenar los números
 * de línea y columna donde se declara la variable. Además, incluye una variable de control booleana para
  * procesamiento adicional.
 * *
 *  * Variables Locales:
 * - Token id: Representa el token identificador para la variable de punto flotante.
 * -  * - int line: Almacena el número de línea donde se declara la variable.
 * - i * - int column: Almacena el número de columna donde se declara la variable.
 * - in * - boolean control: Una bandera de control utilizada para procesamiento o validación adicional.
 */
void VariableFLOAT() : {
    Token id, num;
    int line, column;
    String codigo_temporal;
    boolean control = false;
} {
    try {
        <TipoDatoDecimal>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO || linkers.declaredVariables.containsKey(token.image)) {
                        control = true;
                        linkers.checkAndAddVariable(id, "float[]", line, column);
                        codigo_temporal = "\t int " + id.image + "[" + token.image + "]";
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "float", line, column);
                codigo_temporal = "\tfloat " + id.image;
            }
        }
        [ <Asignacion>
            try {
                num = <NUMERO_FLOTANTE>
                { codigo_temporal += " = " + num.image; }
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        ]
        <DelimitadorLineaDeCodigo>
        { 
            codigo_temporal += "; \n"; 
            acumulador_cpp += codigo_temporal;
        }

    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * Método que maneja la declaración de variables de tipo BOOLEAN en el compilador.
 * 
 * Variables locales:
 * - Token id: Representa el identificador del token.
 * - int line: Almacena la línea del código fuente donde se encuentra la variable.
 * - int column: Almacena la columna del código fuente donde se encuentra la variable.
 * - boolean control: Bandera de control utilizada en el proceso de manejo de la variable.
 * 
 * Este método es parte del archivo de definiciones del compilador y se encarga de 
 * procesar y validar las declaraciones de variables de tipo BOOLEAN en el código fuente.
 */
void VariableBOOLEAN() : {
    Token id, val = null;
    int line, column;
    String codigo_temporal;
    boolean control = false;
} {
    try {
        <TipoDatoBooleano>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO) {
                        control = true;
                        linkers.checkAndAddVariable(id, "boolean[]", line, column);
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "boolean", line, column);
            }
            codigo_temporal = "\tbool " + id.image;
        }
        [ <Asignacion>
            try {
                val = <VERDADERO> | <FALSO>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }            
        ]
        {
            codigo_temporal += " = " + (val.image.equals("Verdadero") ? "true" : "false");
        }
        <DelimitadorLineaDeCodigo>
        {
            codigo_temporal += "; \n";
            acumulador_cpp += codigo_temporal;
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableCADENA() : {
    Token id, value;
    int line, column;
    boolean control = false;
    String codigo_temporal;
} {
    try {
        <TipoDatoCadena>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO) {
                        control = true;
                        linkers.checkAndAddVariable(id, "string[]", line, column);
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "string", line, column);
            }
            codigo_temporal = "\nstring " + id.image;
        }
        [ <Asignacion>
            try {
                value = <CADENA>
                {
                    codigo_temporal += " = " + value.image;
                }
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        ]
        <DelimitadorLineaDeCodigo>
        {
            codigo_temporal += "; \n";
            acumulador_cpp += codigo_temporal;
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void VariableCARACTER() : {
    Token id, value;
    int line, column;
    boolean control = false;
    String codigo_temporal;
} {
    try {
        <TIpoDatoCaracter>
        id = <IDENTIFICADOR>
        {
            line = id.beginLine;
            column = id.beginColumn;
        }
        (
            try {
                <CorcheteAbre> {
                    Token token = getNextToken();
                    if (token.kind == linkersConstants.NUMERO) {
                        control = true;
                        linkers.checkAndAddVariable(id, "char[]", line, column);
                    } else {
                        tabla.add("Error Semántico -> Tamaño de arreglo inválido: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    }
                }
                <CorcheteCierra>
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        )?
        {
            if (!control) {
                linkers.checkAndAddVariable(id, "char", line, column);
            }
            codigo_temporal = "\tchar" + id.image;
        }
        [ <Asignacion>
            try {
                value = <LETRA>
                {
                    codigo_temporal += " = " + value.image;
                }
            } catch (ParseException e) {
                tabla.add("Error de Sintaxis -> " + e.getMessage());
            }
        ]
        <DelimitadorLineaDeCodigo>
        {
            codigo_temporal += "; \n";
            acumulador_cpp += codigo_temporal;
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * Este método representa una regla de asignación en un compilador.
 * 
 * Variables locales:
 * - `id`: Un token que representa el identificador de la variable a la que se le asignará un valor.
 * - `varType`: Una cadena que almacena el tipo de la variable. Inicialmente está vacía.
 * 
 * La implementación de este método debe definir cómo se realiza la asignación de valores a las variables,
 * incluyendo la verificación de tipos y la evaluación de la expresión.
 */
void asignacion() : {
    Token id;
    String varType = ""; 
    String expr = "";    
} {
    try {
        id = <IDENTIFICADOR>
        {
            // Verificar que la variable esté declarada
            if (!linkers.declaredVariables.containsKey(id.image)) {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                varType = linkers.declaredVariables.get(id.image);
            }
        }
        <Asignacion>
        {
            // Generar la expresión
            expr = expresion(varType);
            
            // // Validar que el tipo de la expresión sea compatible
            // if (!verificarCompatibilidadTipos(varType, expr)) {
            //     linkers.tabla.add("Error Semántico -> Tipo incompatible en la asignación. Se esperaba: " + varType + " pero se obtuvo algo diferente en línea " + id.beginLine + ", columna " + id.beginColumn);
            // }
        }
        <DelimitadorLineaDeCodigo>
        {
            // Agregar la traducción al acumulador
            String codigo_temporal = id.image + " = " + expr + ";\n";
            acumulador_cpp += "\t" + codigo_temporal;
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        linkers.tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}


void entrada() : {
    Token token;
} {
    try {
        <Lectura>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            /**
             * Este fragmento de código consume un token del analizador léxico (lexer) en un compilador.
             * 
             * - `jj_consume_token(linkersConstants.IDENTIFICADOR)`: Esta llamada al método `jj_consume_token` 
             *   consume el siguiente token de la secuencia de entrada si coincide con el tipo de token 
             *   especificado, en este caso `linkersConstants.IDENTIFICADOR`. 
             *   Si el token no coincide, se lanzará una excepción de error de sintaxis.
             * 
             * - `Token token`: La variable `token` almacena el token consumido, que puede ser utilizado 
             *   posteriormente en el análisis sintáctico o semántico.
             */
            token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (!linkers.declaredVariables.containsKey(token.image)) {
                linkers.tabla.add("Error Semántico en entrada-> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
            } else {
                String varType = linkers.declaredVariables.get(token.image);
                String codigo_temporal = "";

                switch (varType) {
                    case "int":
                        codigo_temporal = "\tcin >> " + token.image + "; \n";
                        break;
                    case "float":
                        codigo_temporal = "\tcin >> " + token.image + "; \n";
                        break;
                    case "boolean":
                        codigo_temporal = "\tcin >> " + token.image + "; \n";
                        break;
                    case "string":
                        codigo_temporal = "\tcin >> " + token.image + "; \n";
                        break;
                    case "character":
                        codigo_temporal = "\tcin >> " + token.image + "; \n";
                        break;
                    default:
                        linkers.tabla.add("Error Semántico en entrada -> Tipo de variable no soportado: " + varType + " para la variable " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                }

                acumulador_cpp += codigo_temporal;
            }
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

/**
 * El método `salida` es un método que no recibe parámetros y devuelve un valor de tipo `void`.
 * 
 * Dentro del bloque de inicialización del método, se declaran dos variables locales:
 * - `res` 
 * 
 * El método `salida` no tiene un cuerpo de implementación definido en el código proporcionado,
 * lo que sugiere que podría estar incompleto o que su funcionalidad se define en otra parte.
 * 
 */
void salida() : {
    Token token;
    String codigo_temporal = "\tcout << ";
} {
    try {
        <Escritura>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        {
            token = getToken(1);

            if (token.kind == linkersConstants.CADENA) {
                token = jj_consume_token(linkersConstants.CADENA);
                codigo_temporal += token.image;
            } else if (token.kind == linkersConstants.IDENTIFICADOR) {
                token = jj_consume_token(linkersConstants.IDENTIFICADOR);
                String type = linkers.verificarExistenciaYObtenerTipo(token);
                if (!type.equals("error")) {
                    codigo_temporal += token.image;
                }
            } else {
                tabla.add("Error Semántico -> Tipo incorrecto en operación de escritura. Se esperaba: Cadena o Identificador");
            }

            while (nextTokenIs(linkersConstants.OperacionSuma)) {
                jj_consume_token(linkersConstants.OperacionSuma);
                token = getToken(1);
                codigo_temporal += " << ";
                if (token.kind == linkersConstants.CADENA) {
                    token = jj_consume_token(linkersConstants.CADENA);
                    codigo_temporal += token.image;
                } else if (token.kind == linkersConstants.IDENTIFICADOR) {
                    token = jj_consume_token(linkersConstants.IDENTIFICADOR);
                    if (!linkers.declaredVariables.containsKey(token.image)) {
                        tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    } else {
                        codigo_temporal += token.image;
                    }
                } else {
                    tabla.add("Error Semántico -> Tipo incorrecto en operación de escritura. Se esperaba: Cadena o Identificador" + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                    jj_consume_token(token.kind);
                }
            }
            
            codigo_temporal += " << endl; \n";
            acumulador_cpp += codigo_temporal;
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != DelimitadorLineaDeCodigo && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalIf() : {} {
    try {
        {
            if(!casos.isEmpty()){
                casos.clear();
            }
            acumulador_cpp += "\tif (";
        }
        parteIf()
        (
            LOOKAHEAD(2) parteElseIf()
        )*
        (LOOKAHEAD(2) parteElse())?
        
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void parteIf() : {} {
    <CondicionalIf>
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        } 
        condicion()
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <LlaveAbre> {
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }{
            acumulador_cpp += ") { \n\t";
        }
        (sentencias())*
        try {
            <LlaveCierra>{
                acumulador_cpp += "\t} \n";
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
}


void parteElseIf() : {
    Token id;
} {
    try{
        <CondicionalElse>
        {
            acumulador_cpp += "else ";
        }
        
        [
            <CondicionalIf>
                try {
                    <ParentesisAbre>
                } catch (ParseException e) {
                    tabla.add("Error de Sintaxis -> " + e.getMessage());
                }
                {
                    acumulador_cpp += "if (";
                }
                condicion()

                try {
                    <ParentesisCierra>
                } catch (ParseException e) {
                    tabla.add("Error de Sintaxis -> " + e.getMessage());
                }
                { 
                    acumulador_cpp += ")";
                }
        ]
        try {
            <LlaveAbre> {
                acumulador_cpp += " { \n";
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>
            {
                acumulador_cpp += "\t} \n";
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

    }catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void parteElse() : {
    String startLabel = "";
}
{
    try{
        try{
            <CondicionalElse> {
                acumulador_cpp += " else";
            }
        }catch (ParseException e){
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        try {
            <LlaveAbre> {
                acumulador_cpp += " {";
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        try {
            <LlaveCierra>{
                acumulador_cpp += "\t} \n";
            }
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

    }catch (ParseException e ){
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void cicloFor() : {
    Token id, num, operador;
    String varType = "";
    String inicialización = "";
    String condición = "";
    String incremento = "";
} {
    try {
        <CicloFor>
        {
            acumulador_cpp += "for (";
        }
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        LOOKAHEAD (3) declararVariables() | LOOKAHEAD(2) asignacion()
        {
            acumulador_cpp += " ";
        }
        condicion()
        try {
            <DelimitadorLineaDeCodigo>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            acumulador_cpp += "; ";
        }
        asignacionLogica()
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }

        (sentencias())*

        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            acumulador_cpp += "}\n";
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void asignacionLogica() : {
    Token id, num;
    Token operador = null;
    String varType = "";
    String oper = "";
    String operator;
    String incremento = "";
} {
    try {
        id = <IDENTIFICADOR>
        {
            if (!linkers.declaredVariables.containsKey(id.image)) {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                varType = linkers.declaredVariables.get(id.image);
            }
        }
        (
            (
                operator = operadorAritmetico()
            {
                oper = expresion(varType);
                if (!oper.equals(varType)) {
                    linkers.tabla.add("Error Semántico -> Tipo incorrecto en la operación. Se esperaba: " + varType + " pero se obtuvo: " + oper + " en línea " + id.beginLine + ", columna " + id.beginColumn);
                }
            }
            num = <NUMERO>
            {
                incremento = id.image + " " + operator + " " + num.image;
            }
            )
            |
            (
                operador = <OperadorIncremento> | <OperadorDecremento>
                {
                    incremento = operador.image;    
                }    
            )
        )+
        {   
            acumulador_cpp += incremento + ") {\n";
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void cicloWhile() : { } {
    try {
        <CicloWhile>
        {
            acumulador_cpp += "while (";
        }
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        condicion()
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            acumulador_cpp += ") {\n";
        }
        try {
            <LlaveAbre>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        (sentencias())*
        {
        }
        try {
            <LlaveCierra>
        } catch (ParseException e) {
            tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        {
            acumulador_cpp += "}\n";
        }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void condicionalSwitch() : {
    Token id;
    Token num;
} {
    try {
        <CondicionalSwitch>
        {
            acumulador_cpp += "\tswitch (";
        }
        try {
            <ParentesisAbre>
        } catch (ParseException e) {
            linkers.tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        id = <IDENTIFICADOR>
        {
            if (!casos.isEmpty()){
                casos.clear();
            }
            acumulador_cpp += id.image + ") {\n";
        }
        try {
            <ParentesisCierra>
        } catch (ParseException e) {
            linkers.tabla.add("Error de Sintaxis -> " + e.getMessage());
        }
        <LlaveAbre>
        {
            if (!linkers.declaredVariables.containsKey(id.image)) {
                linkers.tabla.add("Error Semántico -> Variable no declarada: " + id.image + " en línea " + id.beginLine + ", columna " + id.beginColumn);
            }
        } 
        (
            caso()
        )*
        (
            defaultCaso()
        )?
        <LlaveCierra>
        {
            acumulador_cpp += "}\n";
        }
    } catch (ParseException e) {
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != LlaveCierra && t.kind != EOF);
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
}

void caso() : {
    Token caseValue, id;
} {
    <Caso>
    caseValue = <NUMERO>
    <DelimitadorCasoSwitch>
    {
        acumulador_cpp += "\tcase " + caseValue.image + ":\n";
    }
    (
        sentencias()
    )*{
    }
    <Break>
    {
        acumulador_cpp += "\tbreak;\n";
    }
    <DelimitadorLineaDeCodigo>
}

void defaultCaso() : {
} {
    <Default>
    <DelimitadorCasoSwitch>
    {
        acumulador_cpp += "\tdefault: \n";
    }
    (
        sentencias()
    )*
}


void condicion() : {} {
    {
        acumulador_cpp += "(";
    }
    condicionSimple()
    (
        operadorLogico()
        {
            acumulador_cpp += " " + token.image + "";
        }
        condicionSimple()
    )*
    {  
        acumulador_cpp += ")";
    }
}

void condicionSimple() : {
    Token token1, token2;
    String type1 = "", type2 = "";
} {
    {
        token1 = valor(); // Permitir cualquier tipo
        type1 = verificarExistenciaYObtenerTipo(token1);
        
        operadorRelacional();
        acumulador_cpp += " " + token.image + " ";
        
        token2 = valor(); // Permitir cualquier tipo
        type2 = verificarExistenciaYObtenerTipo(token2);

        // Verificar que ambos operandos sean del mismo tipo o tipos compatibles
        if (!type2.equals(type2) && !type1.equals("error") && !type2.equals("error")) {
            tabla.add("Error Semántico en condición-> Tipos incompatibles en la condición: " + type1 + " y " + type2);
        }
    }
}

String operadorRelacional() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionMayorQue> { opStr = ">"; }
        | opToken = <OperacionMenorQue> { opStr = "<"; }
        | opToken = <OperacionMenorOIgualQue> { opStr = "<="; }
        | opToken = <OperacionMayorOIgualQue> { opStr = ">="; }
        | opToken = <OperacionIgualdad> { opStr = "=="; }
        | opToken = <OperacionDesigualdad> { opStr = "!="; }
    )
    { return opStr; }
}

String operadorLogico() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionAnd> { opStr = "&"; }
        | opToken = <OperacionOr> { opStr = "|"; }
        | opToken = <OperacionNot> { opStr = "!"; }
    )
    { return opStr; }
}

String operadorAritmetico() : {
    Token opToken;
    String opStr;
} {
    (
        opToken = <OperacionSuma> { opStr = "+"; }
        | opToken = <OperacionResta> { opStr = "-"; }
        | opToken = <OperacionMultiplicacion> { opStr = "*"; }
        | opToken = <OperacionDivision> { opStr = "/"; }
        | opToken = <OperacionResiduo> { opStr = "%"; }
    )
    { return opStr; }
}

String expresion(String expectedType) : {
    String type = expectedType;
    String expr = "";
} {
    expr = termino(expectedType)
    (
        operadorAritmetico()
        {
            Token op = token;
            String sigTerm = termino(expectedType);
            expr += " " + op.image + " " + sigTerm;
        }
    )*
    { return expr; }
}

String termino(String expectedType) : {
    String type = expectedType;
    String term = "";
    String factorType;
} {
    term = factor(expectedType)
    (
        operadorAritmetico()
        {
            Token op = token;
            String sigFactor = factor(expectedType);
            term += " " + op.image + " " + sigFactor;
        }
    )*
    { return term; }
}



String factor(String expectedType) : {
    Token token = null;
    String type = "";
    String res = ""; // Inicialización corregida
} {
    try {
        {if (nextTokenIs(linkersConstants.ParentesisAbre)) {
            jj_consume_token(linkersConstants.ParentesisAbre);
            res = expresion(expectedType);
            jj_consume_token(linkersConstants.ParentesisCierra);
            type = expectedType;
        } else if (nextTokenIs(linkersConstants.NUMERO)) {
            token = jj_consume_token(linkersConstants.NUMERO);
            type = "int";
            res = token.image;
        } else if (nextTokenIs(linkersConstants.NUMERO_FLOTANTE)) {
            token = jj_consume_token(linkersConstants.NUMERO_FLOTANTE);
            type = "float";
            res = token.image;
        } else if (nextTokenIs(linkersConstants.VERDADERO)) {
            token = jj_consume_token(linkersConstants.VERDADERO);
            type = "boolean";
            res = token.image;
        } else if (nextTokenIs(linkersConstants.FALSO)) {
            token = jj_consume_token(linkersConstants.FALSO);
            type = "boolean";
            res = token.image;
        } else if(nextTokenIs(linkersConstants.CADENA)) {
            token = jj_consume_token(linkersConstants.CADENA);
            type = "string";
            res = token.image;
        } else if (nextTokenIs(linkersConstants.LETRA)) {
            token = jj_consume_token(linkersConstants.LETRA);
            type = "character";
            res = token.image;
        } else if (nextTokenIs(linkersConstants.IDENTIFICADOR)) {
            token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (linkers.declaredVariables.containsKey(token.image)) {
                type = linkers.declaredVariables.get(token.image);
                res = token.image;
            } else {
                tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
                type = "error";
            }
        }  else {
            type = "error";
        }
    
        // if (token != null && !type.equals(expectedType) && !type.equals("error")) {
        //     tabla.add("Error Semántico -> Tipo incorrecto. Se esperaba: " + expectedType + " pero se obtuvo: " + type + " en línea " + token.beginLine + ", columna " + token.beginColumn);
        // }
    }
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
    }
    {return (res != null) ? res : "Elemento no encontrado";}
}

boolean nextTokenIs(int kind) : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == kind;}
}

// Métodos auxiliares para detectar operadores
boolean nextTokenIsOperatorLogico() : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersConstants.OperacionAnd || t.kind == linkersConstants.OperacionOr || t.kind == linkersConstants.OperacionNot;}
}

boolean nextTokenIsOperadorAritmetico() : {
    Token t;
} {
    {t = getToken(1);
    return t.kind == linkersConstants.OperacionSuma || t.kind == linkersConstants.OperacionResta || 
           t.kind == linkersConstants.OperacionMultiplicacion || t.kind == linkersConstants.OperacionDivision ||
           t.kind == linkersConstants.OperacionResiduo;}
}

Token valor() : {
    Token token = null;
} {
    try {
        {if (nextTokenIs(linkersConstants.NUMERO)) {
            token = jj_consume_token(linkersConstants.NUMERO);
            acumulador_cpp += token.image;
        } else if (nextTokenIs(linkersConstants.NUMERO_FLOTANTE)) {
            token = jj_consume_token(linkersConstants.NUMERO_FLOTANTE);
            acumulador_cpp += token.image;
        } else if (nextTokenIs(linkersConstants.VERDADERO)) {
            token = jj_consume_token(linkersConstants.VERDADERO);
            acumulador_cpp += "true";
        } else if (nextTokenIs(linkersConstants.FALSO)) {
            token = jj_consume_token(linkersConstants.FALSO);
            acumulador_cpp += "false";
        } else if(nextTokenIs(linkersConstants.CADENA)) {
            token = jj_consume_token(linkersConstants.CADENA);
            acumulador_cpp += token.image;
        } else if (nextTokenIs(linkersConstants.LETRA)) {
            token = jj_consume_token(linkersConstants.LETRA);
            acumulador_cpp += token.image;
        } else if (nextTokenIs(linkersConstants.IDENTIFICADOR)) {
            token = jj_consume_token(linkersConstants.IDENTIFICADOR);
            if (linkers.declaredVariables.containsKey(token.image)) {
                verificarExistenciaVariable(token);
                acumulador_cpp += token.image;
            } else {
                tabla.add("Error Semántico -> Variable no declarada: " + token.image + " en línea " + token.beginLine + ", columna " + token.beginColumn);
            }
        } else {
            tabla.add("Error Semántico -> Token inesperado en la condición.");
            throw new ParseException("Token inesperado en la condición.");
        }}
    } catch (ParseException e) {
        tabla.add("Error de Sintaxis -> " + e.getMessage());
        throw e;
    }
    {return token;}
}

boolean esTipoCompatible(String tipo1, String tipo2) : {} {
    { return (tipo1.equals("int") && tipo2.equals("int")) || 
             (tipo1.equals("float") && (tipo2.equals("int") || tipo2.equals("float"))) || 
             (tipo1.equals("int") && tipo2.equals("float")); }
}

String actualizarTipoResultante(String tipo1, String tipo2) : {
    String tipo;
} {
    {if (tipo1.equals("float") || tipo2.equals("float")) {
        tipo = "float";
    } else if (tipo1.equals("int") && tipo2.equals("int")) {
        tipo ="int";
    } else {
        tipo = "error";
    }}
    {return tipo;}
}


boolean verificarCompatibilidadTipos(String varType, String expr) : {
    boolean compatible = false; // Variable para almacenar el resultado
} {
    {
        // Reglas para validar compatibilidad de tipos
        if (varType.equals("int") && expr.matches("[0-9]+")) {
            compatible = true;
        } else if (varType.equals("float") && expr.matches("[0-9]+(\\.[0-9]+)?")) {
            compatible = true;
        } else if (varType.equals("int") && expr.matches("[0-9]+") && varType.equals("float") && expr.matches("[0-9]+(\\.[0-9]+)?")) {
            compatible = true;
        }else if (varType.equals("boolean") && (expr.equals("true") || expr.equals("false"))) {
            compatible = true;
        } else if (varType.equals("string") && expr.startsWith("\"") && expr.endsWith("\"")) {
            compatible = true;
        }
    }
    { return compatible; }
}

